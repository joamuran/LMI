---
# Informació general del document
title: 6. Programació Orientada a Objectes en JS
subtitle: Llenguatges de marques i sistemes de gestió de la informació (LMSGI)
authors: 
    - José A. Múrcia Andrés
lang: ca
page-background: img/bg.png

# Portada
titlepage: true
titlepage-rule-height: 0
# titlepage-rule-color: AA0000
# titlepage-text-color: AA0000
titlepage-background: img/portada.png
# logo: img/logotext.png

# Taula de continguts
toc: true
toc-own-page: true
toc-title: Continguts

# Capçaleres i peus
header-left: Llenguatges de Marques
header-right: Curs 2024-2025
footer-left: IES Jaume II El Just
footer-right: \thepage/\pageref{LastPage}

# Imatges
float-placement-figure: H
caption-justification: centering

# Llistats de codi
listings-no-page-break: false
listings-disable-line-numbers: false

header-includes:
     - \usepackage{lastpage}
---

En el paradigma d'orientació a objectes, el programari es dissenya a través d'objectes que cooperen, intercanviant missatges i responent a esdeveniments, a diferència del punt de vista tradicional, que considera el programari com un conjunt de funcions.

Vegem alguns conceptes:

* **Classe**: Defineix les característiques de l'objecte.
* **Objecte**: Una instància de la classe.
* **Propietat/Atribut**: Una característica (variable) de l'objecte.
* **Mètode**: Una capacitat (funció) de l'objecte.
* **Constructor**: Mètode que s'invoca en crear l'objecte.
* **Herència**: Capacitat d'una classe d'heretar característiques d'una altra classe.
* **Encapsulament**: Les propietats i els mètodes dels objectes es troben organitzats de manera estructurada, evitant l'accés des de qualsevol forma diferent de les especificades.
* **Polimorfisme**: Mecanisme pel qual diferents classes poden implementar de forma diferent un mateix mètode.

## Orientació a Objectes basada en prototips 

Es tracta d'un estil de programació orientada a objectes en què aquests no es creen a través de la instanciació de classes, sinó mitjançant la clonació d'altres objectes que actuen com a prototips. També es coneix com a programació sense classes, orientada a prototip o basada en exemples.

### Espais de noms

En aplicacions grans, solem utilitzar espais de noms per evitar conflictes entre diferents scripts i llibreries que les componen. Aquests actuen com a contenidors que permeten associar la funcionalitat i les propietats d'un objecte amb un nom únic i aïllat de la resta (podria equiparar-se als `packages` de Java).

En JavaScript no existeix una sintaxi nativa per a aquesta funcionalitat; s'utilitza un objecte per a aquest propòsit. Per exemple:

```js
var app = {}
app.variable1 = 'variable1';
app.variable2 = 'variable2';
app.funcion = function () { .... };
```

La definició d'un objecte prototip en JavaScript no és més que una funció, que fa alhora de constructor:

```js
function Objeto() { 
	// Constructor i inicialització de valors
}
```

I per crear un nou objecte basat en aquest prototip, fem servir `new`:

```js
var obj = new Objeto();
```

Quan es defineix així un objecte, aquest té accés a una propietat especial, denominada prototip (`prototype`), que permet accedir a la classe en si.

Per accedir a propietats dins d'una classe s'utilitza la paraula reservada `this`. Cal tenir cura amb aquesta, perquè quan tenim objectes o propietats aniuats, `this` sempre farà referència a l'objecte del nivell on es troba.

Per accedir des de fora de la classe a un atribut o mètode, fem servir la notació punt (`.`): `Objeto.propiedad / Objeto.método`.

Per exemple, per definir la propietat *nom* d'una classe persona, podem fer-ho en crear la instància:

```js
function Persona(nom) {
	this.nom = nom;
}
```

I per instanciar dues persones noves:

```js
let persona1 = new Persona("Paco");
let persona2 = new Persona("Pepe");

console.log ('persona1 es ' + persona1.nom); // mostra "persona1 es Paco"
console.log ('persona2 es ' + persona2.nom); // mostra "persona2 es Pepe"
```

Per incloure mètodes, definim funcions dins de la classe:

```js
function Persona(nom) {
 this.nom = nom;
 this.saluda = function(){
		alert('Hola, em dic ' + this.nom);
	}
}

var persona1 = new Persona('Paco');
persona1.saluda();
```

Com veiem, els mètodes no són més que funcions que s'associen com una propietat a l'objecte, de manera que poden invocar-se fora del seu context.

***Exemple***

Vegem un exemple complet per a la definició de classes, i que ens servirà per veure altres conceptes com el de l'herència:

```js
/* Exemple de definició de classes */

function punt(x, y){
    /* 
         Funció constructor de la classe punt
	   Rep dos paràmetres amb els que inicialitza 
	   els atributs x i y
     */

	this.x = x;  // Definim atributs amb la paraula 
	this.y = y;  // reservada "this"

	this.get = function(){
		// Els mètodes no són més que funcions
		// Associades a la classe, i que definim
		// amb this, igual que un atribut.
		return "(" + this.x + "," + this.y + ")";
	}
}

function figura(color, posició){
	/*
	    Classe figura, té com a atributs un color
	    i una posició (objecte de tipus punt)
	*/

	this.color = color;	  // Inicialitzem el color
	this.position = posició; // Inicialitzem la posició

	this.draw = function(){
	    /*
              Mètode que mostra un missatge donant 
	      informació de la figura
	    */
	    console.log("Dibuixant figura en posició " + this.position.get() +
                      " i color " + this.color);
	}
}

function rectangle(color, posició, costat1, costat2){
	
	/*
	Classe rectangle, que és una especialització de 
        la classe figura. De figura hereta:
		- l'atribut posició 
		- l'atribut color
	A més:
		- Inclou dos nous atributs: costat1 i costat2
		- Redefineix el mètode draw
		- Defineix un nou mètode area
	*/

	this.costat1 = costat1;
	this.costat2 = costat2;
	/*
	Per heretar propietats de figura, 
	fem ús de "call", passant this com a 
	primer paràmetre, i els valors amb què
	volem invocar al constructor de la
	superclasse
	*/

	figura.call(this, color, posició);

	this.draw = function(){
		console.log("Dibuixant Rectangle de " +
                 this.costat1 + "x" + this.costat2 +
                 " en posició " + this.position.get() +
                 " i color " + this.color);		
		};

	this.area = function(){
		return this.costat1 * this.costat2;
		}
	}


function cercle(color, posició, radi){
	/*
	Classe cercle, hereta de figura: posició i color
	Afig l'atribut radi
	I redefineix el mètode draw i defineix area
	*/

	this.radi = radi;
	// Apply també es pot utilitzar per heretar de la superclasse
	// La diferència és que requereix el pas de paràmetres a través
	// d'un vector:
	figura.apply(this, [color, posició]);

	this.draw = function(){
		console.log("Dibuixant Cercle de radi " + this.radi +
                       " en posició " + this.position.get() +
                       " i color " + this.color);
		};

	this.area = function(){
		return 2 * this.radi * Math.PI;
		}
	}

p1 = new punt(10,20);
p2 = new punt(10,30);
p3 = new punt(30,20);

f1 = new figura("roig", p1);
f2 = new rectangle("verd", p2, 40, 20);
f3 = new cercle("blau", p3, 50);
f1.draw();
f2.draw();
f3.draw();
```

***Exemple 2***

La forma anterior de definir els objectes prototips pot resultar confusa quan es tracta d'objectes que requeriran moltes funcions. Una pràctica habitual és utilitzar l'element `prototype` per accedir al prototip d'una funció i modificar-lo. Vegem-ho més clar amb el mateix exemple expressat d'una altra manera:

```js
/* Exemple de definició de classes */

function punt(x, y){
	/* 
	Classe(Objecte) punt, amb els atributs x i y.
        */
	this.x = x;
	this.y = y;
}

punt.prototype.get = function(){
	/*
	Accedim al prototipus de l'objecte a través de prototype
	I creem una nova propietat "get" que és una funció
	*/	
	return "(" + this.x + "," + this.y + ")";
}

function figura(color, posició){
	this.color = color;
	this.position = posició;
}

figura.prototype.draw = function draw(){
	 // Podem especificar també el nom de la funció després del function
    console.log("Dibuixant figura en posició " + this.position.get() +
                 " i color " + this.color);
}

function rectangle(color, posició

, costat1, costat2){
	this.costat1 = costat1;
	this.costat2 = costat2;
	figura.call(this, color, posició);
}

rectangle.prototype.draw = function(){
		console.log("Dibuixant Rectangle de " + this.costat1 +
                        "x" + this.costat2 + " en posició " +
                      this.position.get() + " i color " + this.color);		
		};

rectangle.prototype.area = function(){
	return this.costat1 * this.costat2;
}

function cercle(color, posició, radi){
	this.radi = radi;
	figura.apply(this, [color, posició]);
}

cercle.prototype.draw = function(){
	console.log("Dibuixant Cercle de radi " + this.radi +
                " en posició " + this.position.get() +
                " i color " + this.color);		
		};

cercle.prototype.area = function(){
	return 2 * this.radi * Math.PI;
}

p1 = new punt(10,20);
p2 = new punt(10,30);
p3 = new punt(30,20);

f1 = new figura("roig", p1);
f2 = new rectangle("verd", p2, 40, 20);
f3 = new cercle("blau", p3, 50);
f1.draw();
f2.draw();
f3.draw();
```

## Orientació a Objectes a partir d’ES6

A partir de la versió EcmaScript 6, JavaScript suporta una sintaxi per a la orientació a objectes més pròxima a la d'altres llenguatges. Cal remarcar que no és una reformulació del model d'objectes, sinó que simplement proporciona definicions més clares i simples per al treball amb objectes.

#### Declaració de classes

Igual que en altres llenguatges, es pot declarar utilitzant la paraula `class`:

```js
class Classe {

}

let objecte = new Classe;
```

Cal tenir en compte alguns detalls:

* La classe no necessita arguments per a la seua definició, per la qual cosa pot no anar acompanyada dels parèntesis (`new Classe` en lloc de `new Classe()`).
* Com que s'ha definit com a classe, el sistema no permetrà que s'execute com una funció (a diferència dels prototips), sinó que es reservarà com un constructor.
* El contingut de la classe s'executa en mode `"strict"` de manera automàtica.
* Les declaracions de classe no segueixen les regles del `*hoisting*` (la declaració pot ser posterior a l'ús). Això significa que les classes només existeixen després de ser declarades.
* Una classe es comporta implícitament com una constant, per la qual cosa no es pot redeclarar més endavant en un mateix àmbit.

Vegem la declaració de classe de forma més ampliada:

```js
class Classe {
    constructor (arguments) {
        // super (arguments); 
        // Declaració d'atributs amb this
    }

    get getAtribut() {
        // getter; compte que el nom no siga el
        // mateix que l'atribut

        return (this.atribut);
    }
    set setAtribut(valor) {
        // setter; compte que el nom no siga el
        // mateix que l'atribut
        this.atribut = valor;
    }

    static staticMethod() {
        // Aquest és un mètode estàtic,
        // S'executarà des de la classe, 
        // no des de les instàncies d'aquesta.
    }

    Metode() {
        // Mètode públic
        // No existeixen per tant els privats o protegits
    }
}
```

#### Herència

L'herència s'aconsegueix mitjançant la paraula clau `extends`:

```js
class Subclasse extends Superclasse {
    constructor(params = {}) {
        // Invocació al constructor de la classe pare
        super(valors);
    }

    metode() {
        // Invocació a mètodes de la classe pare
        super.metode();
    }
}
```

Com podem veure, amb la paraula reservada `super` podem accedir a les propietats i mètodes del pare. Si la utilitzem en forma de funció (`super(valors)`), invoquem al constructor de la classe pare, amb els valors per defecte que li passem. Per la seua banda, quan la utilitzem en forma d'objecte (`super.metode()`), el que fem és invocar un mètode de la classe pare.

Alguns aspectes a destacar sobre l'herència en JavaScript:

* El constructor d'una classe filla ha d'invocar necessàriament `super` abans d'utilitzar `this`.
* Els constructors de les subclasses han d'invocar `super` per inicialitzar la classe o bé retornar un objecte que reemplace l'objecte no inicialitzat.

Vegem finalment com quedaria l'exemple anterior amb aquesta nova sintaxi:

```js
/* Exemple de definició de classes */

class punt {
	constructor(x, y) {
		// Constructor de la classe punt
		// Rep dos paràmetres amb els quals inicialitza 
		// els atributs x i y
		this.x = x; 
		this.y = y;
	}

	get Posicio() {
		return "(" + this.x + "," + this.y + ")";
	}
}

class figura {
	constructor(color, posició) {
		this.color = color;	  // Inicialitzem el color
		this.position = posició; // Inicialitzem la posició
	}

	Dibuixa() {
		console.log("Dibuixant figura en posició " + this.position.Posicio +
                      " i color " + this.color);
	}
}

class rectangle extends figura {
	constructor (color, posició, costat1, costat2) {
		// Hereta de figura la posició i el color
		// Inclou nous atributs: costat1 i costat2

		super(color, posició);
		this.costat1 = costat1;
		this.costat2 = costat2;
	}
	
	Dibuixa() {
		console.log("Dibuixant Rectangle de " +
                this.costat1 + "x" + this.costat2 +
                " en posició " + this.position.Posicio +
                " i color " + this.color);		
	}

	area() {
		return this.costat1 * this.costat2;
	}
}

class cercle extends figura {
	constructor (color, posició, radi) {
		super(color, posició);
		this.radi = radi;
	}
	
	Dibuixa() {
		console.log("Dibuixant Cercle de radi " + this.radi +
                    " en posició " + this.position.Posicio +
                    " i color " + this.color);
	}

	area() {
		return 2 * this.radi * Math.PI;
	}
}

let p1 = new punt(10, 20);
let p2 = new punt(10, 30);
let p3 = new punt(30, 20);

let f1 = new figura("roig", p1);
let f2 = new rectangle("verd", p2, 40, 20);
let f3 = new cercle("blau", p3, 50);
f1.Dibuixa();
f2.Dibuixa();
f3.Dibuixa();
```
