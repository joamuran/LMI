---
# Informació general del document
title: 4. Funcions
subtitle: Llenguatges de marques i sistemes de gestió de la informació (LMSGI)
authors: 
    - José A. Múrcia Andrés
lang: ca
page-background: img/bg.png

# Portada
titlepage: true
titlepage-rule-height: 0
# titlepage-rule-color: AA0000
# titlepage-text-color: AA0000
titlepage-background: img/portada.png
# logo: img/logotext.png

# Taula de continguts
toc: true
toc-own-page: true
toc-title: Continguts

# Capçaleres i peus
header-left: Llenguatges de Marques
header-right: Curs 2024-2025
footer-left: IES Jaume II El Just
footer-right: \thepage/\pageref{LastPage}

# Imatges
float-placement-figure: H
caption-justification: centering

# Llistats de codi
listings-no-page-break: false
listings-disable-line-numbers: false

header-includes:
     - \usepackage{lastpage}
---

# Funcions

La declaració d'una funció en JavaScript es fa amb la paraula reservada `function`. A diferència de Java, les funcions poden declarar-se fora d'un objecte.

```js
function nom_funció(llista_arguments) {
 // Cos de la funció
}
```

El nom de la funció s'utilitza per a fer referència a ella des de qualsevol part del codi. Si volem que la funció ens retorne algun valor i assignar aquest a una variable, farem ús de la paraula reservada `return`. L'ordre dels arguments és important (pas de paràmetres posicional). A més, el nombre de variables utilitzades en invocar la funció no ha de coincidir amb el nombre d'arguments en la declaració.

**Exemple:**

```js
function suma(numero1, numero2) {
 resultat = numero1 + numero2;
 return resultat;
}

s = suma(a, b);
```

Cal recordar que una funció només retorna un valor; si necessitem retornar informació variada, podem utilitzar JSON.

**Exemple:**

```js
function calculaPreu(preu) {
    preu_iva = (preu * 1.21).toFixed(2); // Arrodonim a dos decimals
    preu_iva_reduit = (preu * 1.1).toFixed(2);
    return {"preu_amb_iva": preu_iva, "preu_iva_reduit": preu_iva_reduit};
}

let preus = calculaPreu(50);
console.log(preus);
// Object { preu_amb_iva: "60.50", preu_iva_reduit: "55.00" }
```

## Àmbit de les variables (scope)

L'àmbit d'una variable és la part del programa on està definida i on té sentit. L'àmbit pot ser:

* **global**, visible des de tot el script, o
* **local**, visible només en la funció on es troba declarada (amb `var` o `let`).

Per a entendre bé l'àmbit de les variables, cal tindre en compte alguns aspectes:

* JavaScript és un llenguatge amb *àmbit global* com a àmbit per defecte, on tot es passa també per defecte per referència: quan declarem una variable fora d'una funció, aquesta és global i es passa per referència als àmbits descendents (per tant, qualsevol modificació feta a la variable en qualsevol àmbit tindrà efecte sobre ella).
* Quan declarem una variable amb `var` dins d'una funció, es crea una variable local amb visibilitat restringida a eixa funció.
* Quan definim una variable amb `let` o una constant amb `const`, el seu àmbit es redueix als **blocs** on està definida.

Vegem-ho amb un exemple. El següent codi defineix algunes variables amb `let` i `var` en diferents àmbits:

```js
var var1 = 1;
var var2 = 2;

function fun() {
    var1 = 3;
    var var2 = 4;
    var var3 = 5;
    let var4 = 6;
    {
        var var5 = 7;
        let var6 = 8;
    }

    console.log("Àmbit: Dins la funció:");
    if (typeof(var1) != "undefined") console.log("var1=" + var1);
    if (typeof(var2) != "undefined") console.log("var2=" + var2);
    if (typeof(var3) != "undefined") console.log("var3=" + var3);
    if (typeof(var4) != "undefined") console.log("var4=" + var4);
    if (typeof(var5) != "undefined") console.log("var5=" + var5);
    if (typeof(var6) != "undefined") console.log("var6=" + var6);
}

fun();

console.log("Àmbit: Fora de la funció:");
if (typeof(var1) != "undefined") console.log("var1=" + var1);
if (typeof(var2) != "undefined") console.log("var2=" + var2);
if (typeof(var3) != "undefined") console.log("var3=" + var3);
if (typeof(var4) != "undefined") console.log("var4=" + var4);
if (typeof(var5) != "undefined") console.log("var5=" + var5);
if (typeof(var6) != "undefined") console.log("var6=" + var6);
```

Parem-nos un moment per pensar la sortida que tindrà aquest script i, una vegada ho hàgem pensat, vegem el resultat per a contrastar:

```console
$ nodejs ambits.js
Àmbit: Dins la funció:
var1 = 3
var2 = 4
var3 = 5
var4 = 6
var5 = 7
var6 no està definida
Àmbit: Fora de la funció:
var1 = 3
var2 = 2
var3 no està definida
var4 no està definida
var5 no està definida
var6 no està definida
```

Algunes observacions:

* Dins de la funció, tenim accés a totes les variables definides, tant fora com dins, excepte la variable `var6`, que s'ha definit dins d'un bloc de codi amb la paraula reservada `let`.
* Dins de la funció, `var1` i `var2` han modificat el seu valor, però fora de la funció, la modificació només s'ha mantingut per a `var1`, mentre que `var2` no s'ha modificat. Això es deu al fet que la modificació realitzada sobre `var1` s'ha fet sobre la `referència` a la variable global, mentre que `var2` s'ha definit de nou amb `var` dins de la funció, sent, per tant, una referència diferent de la `var2` definida globalment.
* Finalment, observem que totes les variables definides dins de la funció, independentment de si s'han fet amb `var` o `let`, no tenen visibilitat fora de la funció.

!!! note
    La recomanació és utilitzar sempre la paraula reservada `let` i definir les variables sempre de forma local als àmbits on es necessiten. Quan cal passar variables a una funció, ho farem sempre amb el pas d'arguments.


## Funcions fletxa

L'estàndard ES6 introdueix una forma més concisa de definir funcions: les **funcions fletxa**. Aquestes es declaren amb la notació `() => {}`, on els **arguments** de la funció són la part de l'esquerra de la fletxa (`=>`), i van entre parèntesi, i el **cos** de la funció a la part dreta.

Per exemlple, la funció `suma` que hme definit abans:

```js
function suma(numero1, numero2) { 
 return numero1 + numero2;
}
```

Podreia representar-se com a:

```js
const suma = (numero1, numero2) => {
    return numero1 + numero2;
}
```

A més, quan el cos de la funció conté només una línia, com és el cas anterior, podem ometre el cos `{}` i el `return`, de manera que quede:

```js
const suma = (numero1, numero2) => numero1 + numero2;
```

Un aspecte interessant de les funcions fletxa és que no tenen el seu propi àmbit de `this`. Ho veurme amb més profunditat en la POO.


## Callbacks

Un callback és **una funció** que es passa com a **argument** a una altra funció i que s'invoca dins el codi de la mateixa funció.

Veiem-ho amb un exemple:

```javascript
function saluda(callback) {
    console.log("Hola!");
    callback();
}

function acomiada() {
    console.log("Adéu!");
}

saluda(acomida); 
```

Quin és el resultat de l'execució anterior?

Veiem un altre exemple, fent ús ara de la funció de JS `setTimeout`. Aquesta funció fa una pausa del temps que li indiquem al segon argument, i passat aquest, invoca la funció que li proporcionem com a primer argument (en aquest cas, en forma de funció fletxa):

```js
setTimeout(() => {
    console.log("Això s'executa després de 2 segons.");
}, 2000);
```

## Funcions anònimes

Les funcions, també poden ser anònimes, és a dir, que no tinguen un nom. Aquestes funcions, normalment s'utilitzen en assignacions o com a callbacks.

Veiem-ho amb un exemple, basant-nos en l'anterior:

```js
setTimeout(function() {
    console.log("Hola des d'una funció anònima!");
}, 2000);
```

Veieu que el funcionament és el mateix, amb la diferència que hem reemplaçat la funció fletxa per un `function` al qual no li hem proporcionat nom.

## Funcions com a valors

En JS, les **funcions** són tractades com a **valors**. Això significa que **poden ser assignades a variables**, **emmagatzemades en arrays**, passades com **arguments** o **retornades** per altres funcions.

Per exemple:

```js
const multiplica = (x, y) => x * y;

function opera(funcio, num1, num2) {
    return funcio(num1, num2);
}

let resultat = opera(multiplica, 5, 3); // Crida multiplica(5, 3)
console.log(resultat); // Mostra 15
```

## Closures

Un closure és una funció que *recorda* les variables del seu àmbit extern, fins i tot després que aquest àmbit haja finalitzat.

Veiem un exemple més clar:

```js
function creaSalutacio(nom) {
    let salutacio = `Hola, ${nom}!`;
    return function() {
        console.log(salutacio);
    };
}

let saludaJoan = creaSalutacio("Joan");
saludaJoan(); // Mostra "Hola, Joan!"
```

Els closures en JS ens introdueixen algunes de les idees de la programació orientada a objectes, com l'encapsulació o l'ús de mètodes per manipular dades privades. Veiem alguns exemples per il·lustrar això:

### Encapsulació

Amb els *closures* podem *tancar* variables en un àmbit privat, de manaera que només siguen accessibles mitjançant funcions internes.

```js
function creaComptador() {
    let comptador = 0; // Variable encapsulada

    function incrementa() {
        comptador++;
        console.log(`Comptador: ${comptador}`);
    }

    function decrementa() {
        comptador--;
        console.log(`Comptador: ${comptador}`);
    }

    function consulta() {
        return comptador;
    }

    // Retornem les funcions que necessitem
    return { incrementa, decrementa, consulta };
}

const comptador = creaComptador();

comptador.incrementa(); // Mostra "Comptador: 1"
comptador.incrementa(); // Mostra "Comptador: 2"
comptador.decrementa(); // Mostra "Comptador: 1"
console.log(comptador.consulta());
```

En aquest exemple, la variable comptador es troba encapsulada dins la funció `creaComptador`. Dins la funció hem creat mètodes o funcions (`incrementa`, `decrementa` i `consulta`) que serveixen per accedir, de manera controlada a aquesta variable, ocultant detalls de la seua implementació.

Els closures, a més, permeten mantenir un estat persistent entre les crides a les funcions definides en ell (el valor del comptador no es perd), ja que està guardat en el propi closure.

<!--
## Funcions immediatament invocades (IIFE)

Una **funció immediatament invocada** (*IIFE, Immediately Invoked Function Expressions*) és una funció que s'executa només es defineix. S'utilitza per encapsular variables i evitar conflictes amb altres parts del codi. Veiem-ho amb un exemple:

```js
(function() {
    console.log("Hola des d'una IIFE!");
})();
```

Aquestes funcions són specialment útils quan necessitem encapsular variables i evitar que contaminen l'àmbit global. Això és útil en projectes grans o quan s'integren diversos scripts en una mateixa pàgina.

Per exemple, suposem que estem creant una aplicació i volem definir variables i funcions que no han de ser accessibles des de l'exterior. Podem utlitzar una IIFE per encapsular aquestes funcionalitats:

```js
(function() {
    // Variables i funcions encapsulades
    let contador = 0;

    function incrementa() {
        contador++;
        console.log(`El comptador ara és: ${contador}`);
    }

    function reset() {
        contador = 0;
        console.log("El comptador s'ha reiniciat.");
    }

    // Exposem només el que volem
    window.app = {
        incrementa: incrementa,
        reset: reset
    };
})();
```


Explicació:

Aïllament: Les variables contador, incrementa, i reset només són accessibles dins de la IIFE. Això evita que es sobreescriguen des de fora.
Exposició controlada: Mitjançant l'objecte window.app, exposem únicament les funcions que volem fer accessibles des de fora.

Ús:
Ara podem accedir a les funcionalitats encapsulades sense interferir amb altres parts del codi:

javascript
Copiar código
app.incrementa(); // Mostra: El comptador ara és: 1
app.incrementa(); // Mostra: El comptador ara és: 2
app.reset();      // Mostra: El comptador s'ha reiniciat.
Exemple concret: 

Evitar conflictes amb biblioteques
Si fas servir múltiples biblioteques JavaScript en una mateixa pàgina, una IIFE pot ajudar-te a evitar conflictes entre les variables globals.

javascript
Copiar código
(function($) {
    // Codi que utilitza jQuery
    $(document).ready(function() {
        console.log("Document llest!");
    });
})(jQuery);
Explicació:
En aquest exemple, la IIFE passa jQuery com a paràmetre i l'assigna a $ dins del seu propi àmbit. Això evita conflictes amb altres biblioteques que també podrien utilitzar $.

-->