# Encapsuladió d'estils i plantilles

## Encapsulant estils amb Shadow DOM

Un dels avantatges de Web Components és que podem encapsular els estils **perquè no afecten a la resta de la pàgina**. Veiem com modificar l'exemple de l'apartat anterior:

```js
class MissatgeBenvinguda extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
            <style>
                h2 { 
                    color: darkblue; 
                    font-family: Arial, sans-serif; 
                    }
            </style>
            <h2>Benvingut a LMI!</h2>
        `;
    }
}

customElements.define('missatge-benvinguda', MissatgeBenvinguda);
```

## Optimitzant components amb `template`

Fins ara hem definit directament l'HTML dins d'`innerHTML`. Tot i que això funciona, hi ha una forma més eficient de definir la plantilla d'un Web Component: **les `template`**.

### Què és una `template`?

Una `template` (plantilla) és una etiqueta especial d'HTML que permet definir **un fragment de codi** que no es renderitza automàticament en la pàgina, però que es pot **clonar** i reutilitzar diverses vegades en diferents components.

Veiem-ho en un exemple:

```html
<template id="missatge-template">
    <style>
        h2 {
            color: darkblue;
            font-family: Arial, sans-serif;
        }
    </style>
    <h2>Benvingut a LMI!</h2>
</template>
```

Com podem veure, dins d'una `template` podem definir **tant HTML com CSS**. Aquest contingut **no es mostrarà automàticament** en la pàgina. Perquè es mostre, l'hem de *clonar* (`template.content.cloneNode()`) i afegir manualment al Shadow DOM del component.

>
> Clonar una plantilla no és exclussiu dels Web Components, sinò que es pot fer des de qualsevol codi Javscript.
>

### Ús de `template` dins d'un Web Component

Podem fer ús de *templates* dins un Web Component. Per exemple, una vegada hem definit la plantilla anterior, creem el component següent:

```js
class MissatgeBenvinguda extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        // Busqem la plantilla al document (fent ús de l'id)
        const template = document.getElementById("missatge-template");

        // Clonem el contingut i l'afegim al Shadow DOM
        const clone = template.content.cloneNode(true);
        this.shadowRoot.appendChild(clone);
    }
}

customElements.define('missatge-benvinguda', MissatgeBenvinguda);
```

>
> El mètode cloneNode accepta un paràmetre (`deep`) amb la *profunditat* de la clonació, de manera que:
> * Si és `true`, clona el node i tots els nodes fills.
> * Si és `false`, clona només el node, sense els nodes fills.
> 

Amb les templates aconseguim una major modularitat, un millor rendiment (ja que l'html i el css només es carreguen una vegada i es clonen en cada instància), i s'eviten problemes de renderització.

El principal desavantatge de fer-ho així, és que hem de definir les plantilles a l'html principal, en lloc de fer-ho al propi component. Si estem executant l'aplicació en un servidor, podem tindre la plantilla en un document a banda, i carregar-la dinàmicament amb `fetch`.


### Exemple

Veiem com podriem definir una targeta (*Card*) per mostrar un producte fent ús de plantilles i Web Components.

!!! note "El component Card"

    Les targetes o *Cards* són un element de disseny de Mateterial Design.

    Material Design és un conjunt de principis de disseny introduit per Google el 2014, amb la intenció d'unificar l'experiència visual a Androd, Web i aplicacions. Aquests principis simulen superfícies físiques amb llum, ombres i moviment, per crear interfícies intuïtives i atractives.
    
    El component Card és dels components de Material Design i s'utilitza per agrupar informació de manera organitzada i visualment atractiva. Generalment, té una superfície elevada amb ombres (box-shadow en CSS) per simular profunditat i conté text, imatges, icones o botons dins d'un marc rectangular.

```js
class ProducteCard extends HTMLElement {
    constructor() {
        super();

        // Crea el Shadow DOM
        const shadow = this.attachShadow({ mode: 'open' });

        // Crea la plantilla HTML dins de JavaScript
        const template = document.createElement('template');
        template.innerHTML = `
            <style>
                :host {
                    display: block;
                    margin: 10px 0;
                    border: 1px solid #ddd;
                    border-radius: 10px;
                    padding: 15px;
                    width: 250px;
                    
                    background-color: #f9f9f9;
                    font-family: Arial, sans-serif;

                    box-shadow: 2px 2px 10px rgba(0,0,0,0.1);

                }

                :host .preu{
                    background-color: #ffdd00;
                    padding: 5px;
                    border-radius: 5px;
                    border: 1px solid #efcd00;
                    margin: 2px;

                }

            </style>
            <div>
                <h3>Producte</h3>
                <span class="preu">preu €</span>
                <p>Ací la descripció del producte</p>
            </div>
        `;

        // Clonem la plantilla i l'afegim al shadow DOM
        shadow.appendChild(template.content.cloneNode(true));

    }
}

customElements.define('producte-card', ProducteCard);
```

!!! note "El pseude-element :host"
     Quan volem aplicar estils a tot el web Component (no només als fills), hem de fer ús del pseude-element CSS `:host`, tal i com veiem a l'exemple.

     Aquest vindria a ser com aplicar estils a l'etiqueta HTML que afecten tot el document, però dins el Shadow DOM.