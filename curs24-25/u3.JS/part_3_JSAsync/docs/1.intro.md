# Programació asíncrona en JavaScript

## Introducció

JavaScript és un llenguatge **asíncron i concurrent**, però no paral·lel. Tot i que aprofundirem en aquesta afirmació el pròxim curs, anem a anticipar una miqueta estos conceptes, ja que Javacsript ens permet treballar amb operacions que no segueixen un flux seqüencial com l'accés a serveis d'internet, el treball amb fitxers o l'accés a bases de dades.

***Què vol dir que Javascript és asíncron i concurrent?***

**Asíncron**: El codi pot *delegar* operacions de llarga durada i continuar executant-se sense esperar que aquestes finalitzen.

**Concurrent**: JavaScript gestiona múltiples tasques a través d'un únic fil d'execució (*single-threaded*) utilitzant un mecanisme conegut com a **Event Loop**.

!!!note "2. L'Event Loop"
     L'Event Loop és el mecanisme central que gestiona les tasques en JavaScript:

     1. **Programa principal**: Les instruccions es processen seqüencialment.
     2. **Delegació de tasques**: Quan una operació asíncrona (per exemple, un temporitzador, una petició a a un servei web, o un accés a fitxers o bases de dades) és detectada, es delega i es registra un **callback**.
     3. **Execució dels callbacks**: Els callbacks s'executen en el moment que la tasca en execució acaba, respectant l'ordre a la cua d'esdeveniments.

Veiem un exemple senzill amb diversos tipus de tasques:

```js
console.log("Inici del programa");

setTimeout(() => console.log("Temporitzador de 0 ms"), 0);
Promise.resolve("Promesa resolta").then(console.log);

console.log("Final del programa");
```

Quin seria el resultat esperat? Quin és el resultat quan executem el programa? 

!!!note "Tasques i microtasques"

    L'event loop manté dos cúes diferenciades, amb diferents prioritats:

    * La cúa de **macrotasques**, o programes programats per executar-se al cap d'un temps, i
    * La cúa de **microtasques**, que s'executen només finalitza el codi síncron del programa principal.

    Quan *programem* una macrotasca amb un callback, com hem fet per exemple al temporitzador (`setTimeout`) o fer una consulta a un servidor, aquesta s'afig a la cúa de macrotasques. En canvi, quan programem una microtasca (amb `Promise.then` o `MutationObserve`), aquestes s'sfigen a la cúa de microtasques, i tenen prioritat sobre la de macrotasques.

## **Promeses**

Una **promesa** és un objecte que representa **el resultat futur d'una operació asíncrona**. Una promesa pot estar en un dels tres estats següents:

- **Pending (pendent)**: Encara no ha finalitzat.
- **Fulfilled (resolta)**: Ha acabat amb èxit.
- **Rejected (rebutjada)**: Ha fallat.

Veiem un exemple:

```js
console.log("Inici del programa");
function divideix(dividend, divisor) {
    return new Promise((resolve, reject) => {
        if (divisor === 0) reject("Error: Divisió per zero!");
        else resolve(dividend / divisor);
    });
}

divideix(10, 2)
    .then(result => console.log("Resultat: " + result))
    .catch(error => console.error(error));
console.log("Final del programa");
```

Observeu... Quin és el resultat del programa? Quin tipus de dada *retorna* la funció `divide`. Què són `resolve` i `reject`? Què fan `then` i `catch` i quins paràmetres tenen? 


